/*
 * Copyright (c) 2018 SeNDA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/**
 * FILE SDONController.h
 * AUTHOR MCarmen
 * DATE Jan 26, 2018
 * VERSION 1
 *
 */
#ifndef TOOLS_SDONCONTROLLER_H_
#define TOOLS_SDONCONTROLLER_H_


#include <forward_list>
#include <map>
#include <string>
#include <cstdint>
#include <sstream>
#include <mutex>
#include <condition_variable>
#include <vector>
#include "Lib/adtnSocket.h"
#include "Node/BundleProcessor/OppnetFlow/OppnetFlowTypes.h"

#define LOG_CONTROLLER 68

class NetworkMetricsNotFoundException : public std::exception{
 public:
  NetworkMetricsNotFoundException(){}
  virtual ~NetworkMetricsNotFoundException(){}
  virtual const char* what() const throw (){
    std::stringstream ss;

    ss << "No Network metrics found in bundle";

    return ss.str().c_str();
  }
};

class SDONController {
 public:
  SDONController() = delete;
  /**
   * Default constructor that initializes all the communication parameters needed
   * for the controller to send/recv bundles. Initializes two sockets one for
   * send and the other one for receive. It also establishes the connection with
   * the node, the application wants to receive bundles from.
   * It starts a thread to collect the network metrics for a period of time.
   * @throws adtnException in case the connection with the platform has failed.
   */
  SDONController(std::string nodeIp, int nodePortToSend, int nodePortToRecv,
                 std::string app_addr, std::string send_to_addr,
                 uint64_t windowTime = DEFAULT_RECV_WINDOW_TIME);

  /**
   * Destructor
   */
  virtual ~SDONController();

  /**
   * Method invoked every time a metric is received.
   * @metrics a map with the metrics received. The metrics were encapsulated in
   * a bundle.
   */
  static void printReceivedControlMetrics(
      std::map<NetworkMetricsControlCode, value_t>& metrics);

  /**
   * Method that receives a bundle with metrics information. The receive is a
   * blocking function. Once a metric is received is processed.
   * @return a map table with the collected metrics.
   * @throws NetworkMetricsNotFoundException If the received bundle does not
   * contain any metrics.
   */
  const std::map<NetworkMetricsControlCode, value_t> recvControlMetrics();

  /**
   * Method that receives a bundle with metrics or directives information.
   * @param metrics a vector with all the maps with the network metrics received
   * during a window time.
   * @param directives a vector with all the maps with the controllers directives
   * received during a window time.
   * @param timeout the timeout the receive is blocked.
   * We cannot use the member vectors to store this information as may be
   * they are locked by the consumer who might be  processing them.
   * Therefore we need an accessible vector to add the meanwhile received
   * metrics/directives.
   */
  void recvControlData(
      std::vector<std::map<NetworkMetricsControlCode, value_t>> &metrics,
      std::vector<std::map<DirectiveControlCode, value_t>> &directives,
      const int timeout);

 private:
  static const uint64_t DEFAULT_RECV_WINDOW_TIME = 60;

  /**
   * An application running in a node can receive/send bundles from/to the node
   * where the application is running or from other nodes. The normal case is
   * the first one. This is the Id of the node from where the application will
   * read/write(send/recv) bundles.
   */
  std::string m_nodeIp;
  /**
   * The port used by the node to send the bundles generated by the app.
   */
  int m_nodePortToSend;
  /**
   * The port used by the node to recv the bundles to be consumed by the app.
   */
  int m_nodePortToRecv;
  /**
   * The app will consume, receive, all the bundles which have as destination
   * address this one.
   */
  std::string m_app_addr;
  /**
   * Destination address where the app wants to send the bundle to.
   */
  std::string m_send_to_addr;

  /**
   * Time window while the controller is receiving bundle metrics.
   */
  std::uint64_t m_recvWindowTime;

  /**
   * Socket that will be used by the controller to send bundles.
   */
  adtnSocket m_socket_to_send;

  /**
   * Socket that will be used by the controller to receive bundles.
   */
  adtnSocket m_socket_to_recv;


  /**
   * Mutex used to implement the mutual exclusion section, performed by a
   * unique_lock over this variable. This lock is necessary to implement the
   * locking section between a producer and a consumer for a network metric.
   */
  std::mutex m_mutex;

  /**
   * Condition variable over the control information (metrics /directives)
   * received.
   */
  std::condition_variable m_conditionVariableOverControlInfo;


  std::vector<std::map<DirectiveControlCode, value_t>> m_receivedControlDirectives;

  std::vector<std::map<NetworkMetricsControlCode, value_t>> m_receivedControlMetrics;


  /**
   * Method that launches a thread that collects control metrics for a window
   * time forever. @see collectControlMetricsForAWindowTime().
   */
  void launchControlDataProducer();

  /**
   * Method that launches a thread to wait till there are control Data to be
   * consumed.
   */
  void launchControlDataConsumer();

  /**
   * Method executed by a thread. This method receives control metrics/directives
   * for a window time. Uses a mutex controlled by a lock to implement a mutual
   * exclusion over a variable that contains a Vector with all the collected
   * data during window time. This variable contains always the last window
   * time metrics. If the controller is too slow to consume this data, the
   * new window time collected data will overwrite the old one.
   * In here the receive is not blocking.
   * The method will implement a while true loop.
   */
  void collectControlDataForAWindowTime();

  /**
   *
   */
  void consumeControlData();

  /**
   * Process the metrics collected in a window time infers a directive and sends it
   * in broadcast.
   */
  void processControlData();

  /**
   * For a window time receives ControlMetrics bundles and collects the metrics
   * in a list. After the window time, processes the received metrics and
   * sends, in broadcast, a control directive.
   */
  //void collectControlMetricsForAWindowTimeAndSendDirective();

  /**
   * Launches a thread that for a window time receives ControlMetrics. After
   * this time, with the collected metrics infers a directive and sends it
   * in broadcast. The whole process is done while the platfom is on.
   * It implements  all the logic to add a new thread to the global threads counter
   * and decreases the thread counter when the function finishes.
   */
  //void scheduleCollectControlMetricsAndSendDirective();


  /**
   * After processing the received metrics a directives map is generated and
   * sent.
   * @param directives the map to be encapsulated in a bundle and sent.
   */
  //void sendControlDirectives(std::map<DirectiveControlCode, value_t> directives);

  /**
   * Process the metrics gathered in a list.
   * @param metrics the list of all the metrics to be processed
   */
  /*
  void processControlMetrics(
      std::forward_list<std::map<NetworkMetricsControlCode, value_t>>& metricsLst);
*/

};

#endif  // TOOLS_SDONCONTROLLER_H_
